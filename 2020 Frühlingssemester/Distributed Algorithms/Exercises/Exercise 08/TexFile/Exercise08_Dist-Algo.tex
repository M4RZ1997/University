\documentclass{article}
\usepackage[textheight = 600pt]{geometry}
\usepackage{paralist}
\usepackage[T1]{fontenc}
\usepackage{reledmac}
\usepackage{changepage}
\usepackage{amsmath}
\usepackage{scalerel,amssymb}

\usepackage{pgfplots}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes.geometric, arrows}
\tikzstyle{arrow} = [thick,->,>=stealth]

\usepackage{fancyhdr}
\fancyhead[L]{
	\begin{tabular}{l}
		\LARGE \textbf{\textsc{Distributed Algorithms}} \\
		\Large Exercise 08
	\end{tabular}
}
\fancyhead[R]{
	\begin{tabular}{r}
		16-124-836 \\
		Marcel \textsc{Zauder}
	\end{tabular}
}
\renewcommand{\headrulewidth}{0.4pt}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{0.4pt}

\usepackage{hyperref}

\begin{document}
	\pagestyle{fancy}
	\section*{8.1 Total-Order Broadcast using Consensus}
	\begin{adjustwidth}{2em}{2em}
		\subsection*{(a) Consensus does not sort \textit{deterministically} before \textit{tob-delivering}}
		\begin{adjustwidth}{2em}{2em}
			A consensus decides on a set of messages to deliver. A set normally has in many practical implementations no determinsistic order and therefore all processes could deliver the same set but in a different order which violates the total order property.
		\end{adjustwidth}
		\subsection*{(b) Modifying algorithm s.t. we do not require the sorting of decided payload messages}
		\begin{adjustwidth}{2em}{2em}
		To create a total-order broadcast that does not require the sorting of decided payload messages we can change the implementation s.t. each process proposes a single message to the consensus. The consensus will the agree on delivering one message at a time. This guarantees that all processes deliver the messages in the same sequence.
		\end{adjustwidth}
	\end{adjustwidth}
	
	\section*{8.2 Atomic Register as a Replicated State Machine}
	\begin{center}
		\begin{tabular}{l}
			\underline{upon event} $\langle \textit{nnar, } \textsc{Init} \rangle$ \underline{do} \\
			\ \ $\textit{val} = \emptyset$ \\
			\ \ $\textit{readCount} = 0$ \\
			\ \ $\textit{writeCount} = 0$ \\
			\\
			\underline{upon event} $\langle \textit{nnar, } \textsc{read} \rangle$ \underline{do} \\
			\ \ trigger $\langle tob, \textsc{Broadcast} \mid \textsc{read} \rangle$ \\
			\\
			\underline{upon event} $\langle \textit{nnar, } \textsc{write} \mid v \rangle$ \underline{do} \\
			\ \ trigger $\langle tob, \textsc{Broadcast} \mid [\textsc{write},v] \rangle$ \\
			\\
			\underline{upon event} $\langle \textit{tob, } \textsc{deliver} \mid p, \textsc{read} \rangle$ \underline{do} \\
			\ \ trigger $\langle pl, \textsc{Send} \mid p, [\textsc{ReadAck},val] \rangle$ \\
			\\
			\underline{upon event} $\langle \textit{tob, } \textsc{deliver} \mid p, [\textsc{write},v] \rangle$ \underline{do} \\
			\ \ $\textit{val} = v$ \\
			\ \ trigger $\langle pl, \textsc{Send} \mid p, \textsc{WriteAck} \rangle$ \\
			\\
			\underline{upon event} $\langle \textit{pl, } \textsc{deliver} \mid p, \textsc{WriteAck} \rangle$ \underline{do} \\
			\ \ $\textit{writeCount} = \textit{writeCount} + 1$ \\
			\ \ \textbf{if} $\textit{writeCount} = \mid \Pi \mid$ \textbf{then} \\
			\ \ \ \ $\textit{writeCount} = 0$ \\
			\ \ \ \ trigger $\langle \textit{nnar, } \textsc{WriteReturn} \rangle$ \\
			\\
			\underline{upon event} $\langle \textit{pl, } \textsc{deliver} \mid p, [\textsc{ReadAck},v] \rangle$ \underline{do} \\
			\ \ $\textit{readCount} = \textit{readCount} + 1$ \\
			\ \ \textbf{if} $\textit{readCount} = \mid \Pi \mid$ \textbf{then} \\
			\ \ \ \ $\textit{readCount} = 0$ \\
			\ \ \ \ trigger $\langle \textit{nnar, } \textsc{ReadReturn} \mid v \rangle$ \\
			\\
		\end{tabular}
	\end{center}
	\begin{adjustwidth}{2em}{2em}
		We can ensure that that this implementation terminates because of the validity and agreement properties of the total order-broadcast. These properties say that any message broadcasted by any correct process is eventually delivered by itself, hence both the \textsc{Write} and \textsc{Read} messages will eventually arrive. \\
		Furthermore the property of a total-order broadcast that any set of messages can be  linearized to the same linear sequence across mulitple processes leads to atomicity property s.t. each process eventually has the same sequence of delivered messages. \\
		Therefore it follows that any process deliver message $r_1$ in response to a \textsc{Read} and then returns its locally stored value, any subsequent \textsc{Read} operation with message $r_2$ - delivered after $r_1$ - is ensured to return the same or a newer value.
	\end{adjustwidth}
	
	\section*{8.3 Replicated Register with Local Read}
	\begin{adjustwidth}{2em}{2em}
		Because total-order broadcast only guarantees, that any process has the same history of delivered messages $(m_1 \cdots m_{n-1})$ when delivering message $m_n$, but does not provide  any guarantees what the message sequence of other processes is at that moment or will be in the future. Therefore a local read might break atomicity, i.e.: \\
		\begin{enumerate}
			\item $p$ nnar-writes $x$, broadcasts $[WRITE, x]$
			\item $p$ tob-delivers $[WRITE, x]$, sets $val := x$, nnar-write-returns
			\item $p$ nnar-reads, reads locally, returns $val = x$
			\item $q$ nnar-reads, reads locally, returns $val = \bot$
			\item $q$ tob-delivers  $[WRITE, x]$, sets $val := x$
		\end{enumerate}
		\hfill \\
		The total-order property holds, as the tob-delivered messages of both processes
are $([WRITE, x])$. This implies that both state machines are in sync, but the atomicity property of a regular register is violated because the second read returned the earlier value that the read preceeding it.
	\end{adjustwidth}
\end{document}