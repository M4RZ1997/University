\documentclass{article}
\usepackage{geometry}
\usepackage{paralist}
\usepackage[T1]{fontenc}
\usepackage{reledmac}
\usepackage{changepage}
\usepackage{amsmath}
\usepackage{scalerel,amssymb}

\usepackage{pgfplots}
\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{shapes.geometric, arrows}
\tikzstyle{arrow} = [thick,->,>=stealth]

\usepackage{fancyhdr}
\fancyhead[L]{
	\begin{tabular}{l}
		\LARGE \textbf{\textsc{Distributed Algorithms}} \\
		\Large Exercise 05
	\end{tabular}
}
\fancyhead[R]{
	\begin{tabular}{r}
		16-124-836 \\
		Marcel \textsc{Zauder}
	\end{tabular}
}
\renewcommand{\headrulewidth}{0.4pt}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{0.4pt}

\usepackage{hyperref}

\begin{document}
	\pagestyle{fancy}
	\section*{5.1 (\textsc{new}) Regular Register Executions}
	\begin{adjustwidth}{2em}{2em}
		\subsection*{(a) Algorithm 4.1: Read-One Write-All}
		\begin{adjustwidth}{1em}{2em}
			\subsubsection*{Execution A}
			\begin{adjustwidth}{1em}{}
				The execution A is not possible for the read-one write-all algorithm because a \textit{read} operation will always return the locally stored value. Hence if it is returning the new value a \textit{read} operation sequentially after the first process on the same process will also return the new value and can't return the old one.
			\end{adjustwidth}
			\subsubsection*{Execution B}
			\begin{adjustwidth}{1em}{}
				The non-concurrent \textit{write} and \textit{read} operation working as expected and will follow the validity property. Therefore any healthy process will have written and stored the new value. \\
				Now we consider the two concurrent read operations. Furthermore we assume that $p.\textit{Write}(y)$ to happen immediately after it starts. The \textit{read} operation of $r$ can therefore return the value $y$. As process $q$ might be a bit slower, as the \textit{read} operation is caled it still can return the value $x$ because it has not received the or terminated the \textit{write} operation.
			\end{adjustwidth}
		\end{adjustwidth}
		\subsection*{(b) Algorithm 4.2: Majority Voting Regular Register}
		\begin{adjustwidth}{1em}{2em}
			\subsubsection*{Execution A}
			\begin{adjustwidth}{1em}{}
				Again the non-concurrent \textit{read/write} operations work according to the validity property. \\
				For the two \textit{read} operation which are concurrent with the \textit{write} operation we assume the following: As $q$ is first reading it receives a message from $q$ and $p$. Process $q$ still has the value of $x$ stored but $p$ has already written $y$. Because $y$ will have the higher timestamp the \textit{read} operation will return $y$. For the second \textit{read} operation $q$ will receive messages from $q$ and $r$ which is also a moajority but both have not finished writing the new value and therefore returning $x$ hence the \textit{read} operation is returning it as well.
			\end{adjustwidth}
			\subsubsection*{Execution B}
			\begin{adjustwidth}{1em}{}
				This execution is similar to the Execution A. Process $r$ can receive a message from a process which has already written the new value $y$ and process $q$ receives only messages of processes that don't.
			\end{adjustwidth}
		\end{adjustwidth}
	\end{adjustwidth}
	
	\section*{5.2 Read-All Write-One Regular Register}
	\begin{adjustwidth}{2em}{2em}
		\begin{center}
			\begin{tabular}{l}
				\underline{\textbf{Implements:}} \\
				\ \ (1,N)-RegularRegister, \textbf{instance} \textit{onrr} \\
				\underline{\textbf{Uses:}} \\
				\ \ BestEffortBroadcast, \textbf{instance} \textit{beb} \\
				\ \ PerfectPointToPointLinks, \textbf{instance} \textit{pl} \\
				\ \ PerfectFailureDetector, \textbf{instance} $\mathbb{P}$ \\
				\\
				\underline{upon} \textbf{event} $\langle \textit{onrr, Init} \rangle$ \underline{do} \\ 
				\ \ $val \leftarrow \bot$ \\
				\ \ $correct \leftarrow \Pi$ \\
				\ \ $wid \leftarrow 0$ \\
				\ \ $rid \leftarrow 0$ \\
				\ \ $readList \leftarrow []$ \\
				\\
				\underline{upon} \textbf{event} $\langle \mathbb{P}, \textit{Crash} \mid p \rangle$ \underline{do} \\
				\ \ $correct = correct \setminus \{ p \}$ \\
				\\
				\underline{upon} \textbf{event} $\langle \textit{onrr, Read} \rangle$ \underline{do} \\
				\ \ $rid = rid + 1$ \\
				\ \ \underline{trigger} $\langle \textit{beb, Broadcast} \mid [\textsc{Read}, \textit{rid}] \rangle$ \\
				\\
				\underline{upon} \textbf{event} $\langle \textit{onrr, Write} \mid v \rangle$ \underline{do} \\
				\ \ $val \leftarrow v$ \\
				\ \ $wid := wid + 1$ \\
				\ \ \underline{trigger} $\langle \textit{onrr, WriteReturn} \rangle$ \\
				\\
				\underline{upon} \textbf{event} $\langle \textit{beb, Deliver} \mid q, [\textsc{Read}, \textit{rid}] \rangle$ \\
				\ \ \underline{trigger} $\langle \textit{pl, Send} \mid q, [\textsc{Value}, rid, wid, val] \rangle$ \\
				\\
				\underline{upon} \textbf{event} $\langle \textit{pl, Deliver} \mid q, [\textsc{Value}, r, id', v'] \rangle$ s.t. $r = rid$\\
				\ \ $readList[q] \leftarrow (id', v')$ \\
				\ \ \underline{if} $\#(readList) == \#(correct)$ \underline{then} \\
				\ \ \ \ $v = \textit{highestval(readList)}$ \\
				\ \ \ \ $readList = []$ \\
				\ \ \ \ \underline{trigger} $\langle \textit{onrr, ReadReturn} \mid v \rangle$
				
			\end{tabular}
		\end{center}
	\end{adjustwidth}
	
	\section*{5.3 (1,1) Atomic Register}
	\begin{adjustwidth}{2em}{2em}
		We can modify a reader process which is implemented as the Algorithm 4.2 such that it will store the latest value. The \textit{read} operation is executed as described in Algorithm 4.2 but before the \textit{ReadReturn} it can compare the value with the highest timestamp it received with the $(wts, val)$ pair it has stored. If the timestamp it has received is higher than the one it has stored it can update its pair. In the end it will return the value with the highest timestamp and hence we implemented an algorithm for a (1,1) \textsc{atomic} register.
	\end{adjustwidth}
\end{document}