\documentclass{report}
\usepackage[headheight=30pt, textheight=580pt]{geometry}
\usepackage{paralist}
\usepackage{scalerel,amssymb}
\usepackage{amsmath}
\usepackage{colortbl}
\usepackage{array}
\usepackage{multirow}

\usepackage{graphicx}
\usepackage{stix}

\newcommand{\tableflip}{$($\rotatebox{45}{$\smile$}$^{\circ}\smwhtsquare^{\circ})\rotatebox{45}{$\smile$}\mkern-6mu\frown$\raisebox{0.5ex}{$\bot$}$\mkern-3.5mu-\mkern-3.5mu$\raisebox{0.5ex}{$\bot$}}

\usepackage{fancyhdr}
\fancyhead[L]{\LARGE Cryptography \\
\Large Exercise 07}
\fancyhead[R]{16-124-836 \\
Marcel \textsc{Zauder}}
\renewcommand{\headrulewidth}{0.4pt}
\fancyfoot[C]{\thepage}
\renewcommand{\footrulewidth}{0.4pt}

\usepackage{hyperref}

\begin{document}
	\pagestyle{fancy}
	
	\section*{7.1 PRF using PRG}
	\subsection*{7.1.a G is injective}
	\begin{enumerate}[]
		\item Let $g$ be the return value of $G(x)$. Because $G(x)$  is injective this $g$ can be only reached once by any input $x$. Therefore the following holds:
		\[
			F'(k,x) \ = \ F(k, G(x)) \ = \ F(k, g)
		\]
		Furthermore $g$ is in $\{ 0,1 \} ^{2 \lambda}$. Because we know that $F$ is secure for any input $k$ and $g$ and $g$ is an arbitrary $2 \lambda$ bit-string, $F'$ is also secure.
	\end{enumerate}
	\subsection*{7.1.b H and G}
	\begin{enumerate}[]
		\item We consider the following distinguisher: \\
		\begin{tabular}{ll}
			\begin{tabular}{|l|}
				\hline \cellcolor[gray]{0.8}$Distinguisher \ A$ \\
				\ \textbf{pick} $x \in \{ 0,1 \} ^{\lambda-1}$ \\
				\ $s1 \ = \ x \ \| \ 0$ \\
				\ $s2 \ = \ x \ \| \ 1$ \\
				\ \textbf{return} $\textsc{Lookup}(s1) \ = \ \textsc{Lookup}(s2)$ \\ \hline
			\end{tabular}
			&
			\begin{tabular}{p{7.5cm}}
				First we will pick a random seed x and concatenate it once with $0$ and with $1$. These two $\lambda$ bit-strings are then put in the \textsc{Lookup}-function. In the end we will check if both outputs are equal.
			\end{tabular}
		\end{tabular}
		\\ \\ \\
		\begin{tabular}{lllll}
			\begin{tabular}{|l|}
				\hline \cellcolor[gray]{0.8}$Distinguisher \ A$ \\
				\ \textbf{pick} $x \in \{ 0,1 \} ^{\lambda-1}$ \\
				\ $s1 \ = \ x \ \| \ 0$ \\
				\ $s2 \ = \ x \ \| \ 1$ \\
				\ \textbf{return} $\textsc{Lookup}(s1) \ = \ \textsc{Lookup}(s2)$ \\ \hline
			\end{tabular}
			&
			$\diamond$
			&
			\begin{tabular}{|l|}
				\hline \cellcolor[gray]{0.8}$L^{F'}_{PRF-real}$ \\
				\ $k \leftarrow \{ 0,1 \} ^{\lambda}$ \\
				\\
				\ \underline{\textsc{Lookup}(x)}\\
				\ \ \ $g \ = \ \stackrel{\sim}{G}(x)$ \\
				\ \ \ \textbf{return} $F(k, g)$ \\ \hline
			\end{tabular}
			&
			$\diamond$
			&
			\begin{tabular}{|l|}
				\hline \cellcolor[gray]{0.8}$L^{\stackrel{\sim}{G}}_{PRF-real}$ \\
				\ $h \ = \ H(x_1 \cdots x_{\lambda-1})$ \\
				\ \textbf{return} $h$ \\ \hline
			\end{tabular}
		\end{tabular}
		\\ \\ \\
		It is obvious that the algorithm combined with $L^{F'}_{PRF-real}$ will always output 1 because there will be no difference between the outputs if in the inputs only the last bit is different. \\ \\
		\begin{tabular}{lll}
			\begin{tabular}{|l|}
				\hline \cellcolor[gray]{0.8}$Distinguisher \ A$ \\
				\ \textbf{pick} $x \in \{ 0,1 \} ^{\lambda-1}$ \\
				\ $s1 \ = \ x \ \| \ 0$ \\
				\ $s2 \ = \ x \ \| \ 1$ \\
				\ \textbf{return} $\textsc{Lookup}(s1) \ = \ \textsc{Lookup}(s2)$ \\ \hline
			\end{tabular}
			&
			$\diamond$
			&
			\begin{tabular}{|l|}
				\hline \cellcolor[gray]{0.8}$L^{F'}_{PRF-rand}$ \\
				\ $T \ := \ empty \ associated \ array$ \\
				\\
				\ \underline{\textsc{Lookup}(x)}\\
				\ \ \ \textbf{if} $T[x]$ undefined: \\
				\ \ \ \ \ $T[x] \leftarrow \{ 0,1 \} ^{2 \lambda}$ \\
				\ \ \ \textbf{return} $T[x]$ \\ \hline
			\end{tabular}
		\end{tabular}
		\\ \\
		This combination will only return 1 if for $s1$ and $s2$ the same outputs are saved in T. The probability for this is $2^{-\lambda}$.
		\\
		For the advantage, we get:
		\[
			Bias(A) \ = \ \mid P[A \diamond L^{F'}_{PRF-Real} \rightarrow 1] - P[A \diamond L^{F'}_{PRF-Rand} \rightarrow 1] \mid \ = \ 1 - 2^{-\lambda} \\
		\]
		, which is clearly not negligible for $\lambda \rightarrow \infty$.
	\end{enumerate}
	
	\section*{7.2 Pseudo-random Permutations}
	\section*{7.2.a Probability of collisions}
	\begin{enumerate}[]
		\item The PRP can output $2^{\lambda}$ different permutations. \\
		Furthermore if we have blocklength $\mu$, there can be $\mu !$ different permutations. Therefore the probability that one of them will agreef with one permutation generated by the PRP will be:
		\[
			Pr[permutation \ is \ one \ of \ PRP] \ = \  \frac{2^{\lambda}}{\mu !}
		\]
	\end{enumerate}
	\section*{7.2.b $\lambda$ = $\mu$ = 128}
	\begin{enumerate}[]
		\item When $\lambda$ = $\mu$ = 128 we have $2^{128}$ possible keys that can be created. For the probability we then get:
		\[
			Pr[permutation \ is \ one \ of \ PRP] \ = \ \frac{2^{128}}{128!}\ \approx \ 8.82 * 10^{-178}
		\]
		This probability is pretty much negligible and it is very much unlikely that this would be the case.
	\end{enumerate}
	\hfill \\
	\section*{7.3 Insecurity of two-round keyed Feistel cipher}
	\begin{enumerate}[]
		\item We know that $M = L_0 \| R_0$. Therefore we also know that:
		\[
			C \ = \ L_2 \| R_2 \ = \ L_0 \oplus F(K_0, R_0) \| R_0 \oplus F(K_1, L_0 \oplus F(K_0, R_0)) 
		\]
		With this we can compute the following things:
		\begin{align*}
			L_0 \oplus L_2 \ & = \ F(K_0, R_0) \\
			R_0 \oplus R_2 \ & = \ F(K_1, L_0 \oplus F(K_0, R_0)) 
		\end{align*}
		With these information it is not impossible to find out $K_0$ and $K_1$ and therefore the two-round keyed Feistel cipher is not secure.
	\end{enumerate}
	
\end{document}